To do:
for tree, connect sibling nodes: x->y y->z ...

Primitives:
[ ] 05.01 compute parity of a word
[ ] 05.02 swap bits
[ ] 05.03 reverse bits
[ ] 05.04 find a closest integer with same weight
[ ] 05.05 compute x * y without arithmetic operators
[ ] 05.06 compute x / y
[ ] 05.07 compute x ^ y
[ ] 05.08 reverse digits
[ ] 05.09 check if decimal number is a palindrome
[ ] 05.10 generate uniform random numbers
[ ] 05.11 rectangle intersection

Arrays:
[ ] 06.01 dutch national flag problem
[ ] 06.02 increment an arbitrary precision integer
[ ] 06.03 multiply 2 arbitrary precision integers
[ ] 06.04 advancing through an array
[ ] 06.05 delete duplicates from sorted array
[ ] 06.06 buy and sell a stock once
[ ] 06.07 buy and sell a stock twice
[ ] 06.08 enum all primes to n
[ ] 06.09 permute elements of an array
[ ] 06.10 compute the next permutation
[ ] 06.11 sample offline data
[ ] 06.12 sample online data
[ ] 06.13 compute a random permutation
[ ] 06.14 compute a random subset
[ ] 06.15 generate non-uniform random numbers
[ ] 06.16 sudoku checker problem
[ ] 06.17 compute spiral ordering of 2d array
[ ] 06.18 rotate 2d array
[ ] 06.19 compute rows in pascals triangle

Strings:
[ ] 07.01 interconvert strings and integers
[ ] 07.02 base conversion
[ ] 07.03 compute spreadsheet column encoding
[ ] 07.04 replace and remove
[ ] 07.05 test palindromicity
[ ] 07.06 reverse all words in a sentence
[ ] 07.07 compute all mnemonics for phone number
[ ] 07.08 look-and-say problem
[ ] 07.09 convert from roman to decimal
[ ] 07.10 compute all valid IP addresses
[ ] 07.11 write a string sinusoidally
[ ] 07.12 implement RLE
[ ] 07.13 find 1st occurence of substring

Linked Lists:
[ ] 08.01 merge 2 sorted lists
[ ] 08.02 reverse a single sublist
[ ] 08.03 test for cyclicity
[ ] 08.04 test for overlapping lists - lists cycle free
[ ] 08.05 test for overlapping lists - lists may have cycles
[ ] 08.06 delete node from single linked list
[ ] 08.07 remove kth last element from single linked list
[ ] 08.08 remove duplicates from sorted list
[ ] 08.09 implement cyclic right shift for singly linked lists
[ ] 08.10 implement even-odd merge
[ ] 08.11 test if single linked list is palindromic
[ ] 08.12 implement list pivoting
[ ] 08.13 add list-based integers

Stacks/Queues:
[ ] 09.01 implement stack with max API
[ ] 09.02 evaluate RPN expressions
[ ] 09.03 test a string over "{,},(,),[,]" for well-formedness
[ ] 09.04 normalize pathnames
[ ] 09.05 search a postings list
[ ] 09.06 compute buildings with sunset view
[ ] 09.07 compute binary tree nodes in order of increasing depth
[ ] 09.08 implement circular queue
[ ] 09.09 implement queue using stacks
[ ] 09.10 implement queue with max API

Binary Trees:
[ ] 10.01 test if binary tree is height-balanced
[ ] 10.02 test if binary tree is symmetric
[ ] 10.03 compute LCA in binary tree
[ ] 10.04 compute LCA when nodes have parent pointers
[ ] 10.05 sum the root-to-leaf  paths in binary tree
[ ] 10.06 find root to leaf path with specified sum
[ ] 10.07 implement non-recursive inorder traversal
[ ] 10.08 implement non-recursive preorder traversal
[ ] 10.09 compute kth node in inorder traversal
[ ] 10.10 compute successor
[ ] 10.11 implement inorder traversal with O(1) space
[ ] 10.12 reconstruct binary tree from traversal data
[ ] 10.13 reconstruct binary tree from preorder traversal markers
[ ] 10.14 form linked-list from leaves of binary tree
[ ] 10.15 compute exterior of binary tree
[ ] 10.16 compute right sibling tree
[ ] 10.17 implement locking in binary tree

Binary Search Trees:
[ ] 15.01 test if binary tree is a BST
[ ] 15.02 find 1st key greater than given value in BST
[ ] 15.03 find k largest elements in BST
[ ] 15.04 compute LCA in BST
[ ] 15.05 reconstruct BST from traversal data
[ ] 15.06 find closest entries in 3 sorted arrays
[ ] 15.07 enum nums of the form a + b*sqrt(2)
[ ] 15.08 most visited pages problem
[ ] 15.09 build min height BST from sorted array
[ ] 15.10 insert / delete into BST
[ ] 15.11 test if 3 bst nodes are totally ordered
[ ] 15.12 range lookup problem
[ ] 15.13 add credits

Heaps: 
[x] 11.01 merge sorted files
[x] 11.02 sort increasing-decreasing array
[ ] 11.03 sort an almost sorted array
[ ] 11.04 compute k closest stars
[ ] 11.05 compute median of online data
[ ] 11.06 compute k largest elements in max-heap
[ ] 11.07 implement stack API using heap

Searching:
[ ] 12.01 search sorted array for 1st occurence of k
[ ] 12.02 search sorted array for entry at index
[ ] 12.03 search a cyclically sorted array
[ ] 12.04 compute integer square root
[ ] 12.05 compute real square root
[ ] 12.06 search 2d sorted array
[ ] 12.07 find min/max simultaneously
[ ] 12.08 find kth largest element
[ ] 12.09 find missing IP address
[ ] 12.10 find the duplicate and missing elements

Hash:
[ ] 13.01 test palindromic permutations
[ ] 13.02 is anonymous letter constructable?
[ ] 13.03 implement isbn cache
[ ] 13.04 compute LCA, optimize for close ancestors
[ ] 13.05 compute k most frequent entries
[ ] 13.06 find nearest repeated entries in array
[ ] 13.07 find smallest subarray covering all values
[ ] 13.08 find smallest subarray sequentially covering all values
[ ] 13.09 find longest subarray with distinct entries
[ ] 13.11 compute avg of top 3 scores
[ ] 13.12 compute all string decompositions
[ ] 13.13 test Collatz conjecture
[ ] 13.14 implement hash function for chess

Sorting:
[ ] 14.01 compute intersect of 2 sorted arrays
[ ] 14.02 merge 2 sorted arrays
[ ] 14.03 remove first name duplicates
[ ] 14.04 render a calendar
[ ] 14.05 merging intervals
[ ] 14.06 compute union of intervals
[ ] 14.07 partition & sort array w/many repeated entries
[ ] 14.08 team photo day 1
[ ] 14.09 fast sort for lists
[ ] 14.10 compute salary threshold

Recursion:
[ ] 16.01 towers of hanoi
[ ] 16.02 n queens
[ ] 16.03 generate permutations
[ ] 16.04 generate power set
[ ] 16.05 generate all subsets of size k
[ ] 16.06 generate strings of matching parens
[ ] 16.07 generate palindromic decompositions
[ ] 16.08 generate binary trees
[ ] 16.09 implement sudoku solver
[ ] 16.10 compute gray code
[ ] 16.11 compute diameter of a tree

Dynamic Programming:
[ ] 17.01 count number score combos
[ ] 17.02 levenshtein distance
[ ] 17.03 number ways to traverse 2d array
[ ] 17.04 binomial coeffs
[ ] 17.05 search for sequence in 2d array
[ ] 17.06 knapsack
[ ] 17.07 bedbathandbeyond.com problem
[ ] 17.08 find min weight path in triangle
[ ] 17.09 pick up coins for max gain
[ ] 17.10 count num moves to climb stairs
[ ] 17.11 pretty printing
[ ] 17.12 find longest non-decreasing sequence

Greedy:
[ ] 18.01 optimum assignment of tasks
[ ] 18.02 schedule minimum waiting time
[ ] 18.03 interval covering problem
[ ] 18.04 3-sum problem
[ ] 18.05 find majority element
[ ] 18.06 gasup problem
[ ] 18.07 max water trapped by pair vert lines
[ ] 18.08 largest rectangle under skyline

Graphs:
[ ] 19.01 search maze
[ ] 19.02 paint boolean matrix
[ ] 19.03 compute enclosed regions
[ ] 19.04 deadlock detection
[ ] 19.05 clone a graph
[ ] 19.06 making wired connections
[ ] 19.07 transform one string to another
[ ] 19.08 team photo day 2
[ ] 19.09 shortest path w/fewest edges

Parallel:
[ ] 20.01 caching for multithreaded dictionary
[ ] 20.02 unsynchronized interleaved threads
[ ] 20.03 synchronize interleaving threads
[ ] 20.04 thread pool
[ ] 20.05 deadlock
[ ] 20.06 reader/writer
[ ] 20.07 reader/writer - writer preference
[ ] 20.08 timer
[ ] 20.09 parallel collatz conjecture

Extra:
[ ] map reduce
[ ] bloom filters
[ ] hyper log log
[ ] SHA
[ ] locality-sensitive hashing
[ ] diffie-hellman key exchange
[ ] linear programming

Notes:
Bits: http://www.graphics.stanford.edu/~seander/bithacks.html
http://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/

c files:
=======
sort  -> merge sort, quicksort, heapsort
graph ->dijkstra -> MST
trie  -> (lex search) -> see wiki - use as a hash front-end to reduce density
tree  -> ordered set
hash  -> unordered set
issue: ring.inc and stak.inc

Hash: recall previous values - anagrams

Heaps: 
    Order statistics: K/Kth largest elements
    Heap sort - in place, no quadratic scenarios
    Dijkstra's algorithm (shortest path), 
    Prim's algorithm (minimum spanning tree) 
    Huffman encoding (data compression).    
    Selection - min, max, median, kth in sublinear time
    Priority Queue

Total = 186

Data structures (@geeks)
===============
Binary Indexed Tree or Fenwick tree
Segment Tree (RMQ, Range Sum and Lazy Propagation)
K-D tree (See insert, minimum and delete)
Union Find Disjoint Set (Cycle Detection and By Rank and Path Compression)
Tries
Suffix array (this, this and this)
Sparse table
Suffix automata
Suffix automata II
LCA and RMQ


