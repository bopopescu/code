;==========================================================
;Header
;==========================================================
        .nolist
#ifdef	VTI
	#define TI83P
#endif
	#include	"keyval.inc"
        #include        "ion.inc"
        .list

#ifdef  TI83P
        .org    progstart-2
        .db     $BB,$6D
#else
        .org    progstart
#endif
        ret
        jr      nc,start_of_program
        .db     "Grayscale Zelda 0.001",0

zeldaX		=saferam3
zeldaY		=saferam3+1
supermapX	=saferam3+2
supermapY	=saferam3+3
viewmapX	=saferam3+4
viewmapY	=saferam3+5
viewX		=saferam3+6
viewY		=saferam3+7
X		=saferam3+8
Y		=saferam3+9

zeldaDirection	=saferam3+10

OldX		=saferam3+11
OldY		=saferam3+12
CharCycle	=saferam3+13

start_of_program:
;==========================================================
; start of program
;==========================================================
	call gsEnable
	call NewGameVars

	call EnterSubMap

	call gsSetFreq

loop:
	call checkKeys
	call gsClearbuffer
	call mapDrawView
	call charDraw
	call gsCopyBuffer
	jr loop

quit:
	call gsDisable
	ret




;==========================================================
; EnterSubMap
;==========================================================
EnterSubMap:
	xor a
	ld (charCycle),a

	call mapCreateSubMap
	ret

;==========================================================
; DrawScreen
;==========================================================
	call gsClearbuffer
	call mapDrawView
	call charDraw
	call gsCopyBuffer
	ret

;==========================================================
; NewGameVars
;==========================================================
NewGameVars:
	ld a,10
	ld (zeldaX),a
	ld (oldX),a
	ld a,10
	ld (zeldaY),a
	ld (oldY),a
	ld a,6
	ld (viewX),a
	ld a,7
	ld (viewY),a
	ld a,2
	ld (zeldaDirection),a
	ld a,2
	ld (superMapX),a
	ld a,4
	ld (superMapY),a
	ld a,255
	ld (charCycle),a
	ret

;==========================================================
; checkKeys
;==========================================================
checkKeys:

	ld a,(zeldaY)
	ld (OldY),a
	ld a,(zeldaX)
	ld (OldX),a

	call gsGetk
	cp gLeft	\ jr z,ck_left
	cp gRight	\ jr z,ck_right
	cp gUp		\ jr z,ck_up
	cp gDown	\ jr z,ck_down
	cp gClear	\ jr z,ck_quit
	ret
ck_left:
	ld a,(zeldaX)
	dec a
	cp 255 \ jr z,ck_goscreenleft
	ld (zeldaX),a
	ld a,3
	ld (zeldaDirection),a
	jr ck_redraw
ck_right:
	ld a,(zeldaX)
	inc a
	cp 19 \ jr z,ck_goscreenright
	ld (zeldaX),a
	ld a,1
	ld (zeldaDirection),a
	jr ck_redraw
ck_up:
	ld a,(zeldaY)
	dec a
	cp 255 \ jr z,ck_goscreenup
	ld (zeldaY),a
	xor a
	ld (zeldaDirection),a
	jr ck_redraw
ck_down:
	ld a,(zeldaY)
	inc a
	cp 15 \ jr z,ck_goscreendown
	ld (zeldaY),a
	ld a,2
	ld (zeldaDirection),a
	jr ck_redraw
ck_quit:
	pop hl
	call gsDisable
	ret

ck_goscreenleft:
	ld a,18
	ld (zeldaX),a
	ld hl,supermapX
	dec (hl)
	jr ck_reloadscreen 
ck_goscreenright:
	xor a
	ld (zeldaX),a
	ld hl,supermapX
	inc (hl)
	jr ck_reloadscreen 
ck_goscreenup:
	ld a,14
	ld (zeldaY),a
	ld hl,supermapY
	dec (hl)
	jr ck_reloadscreen 
ck_goscreendown:
	xor a
	ld (zeldaY),a
	ld hl,supermapY
	inc (hl)
ck_reloadscreen:
	call EnterSubMap

ck_redraw:
	;=== switch cycle
	ld hl,charCycle
	ld a,(hl)
	xor 1
	ld (hl),a
	
	;=== check tile
	ld a,(zeldaX)
	ld b,a
	ld a,(zeldaY)
	ld c,a
	ld de,2*256+2
	call mapCheckLargePos
	cp 32 \ jr c,ck_nowrongpos
	ld a,(OldX)
	ld (zeldaX),a
	ld a,(OldY)
	ld (zeldaY),a

ck_nowrongpos:
	;=== update viewX
	ld a,(zeldaX)
	sub 4
	cp 200 \ jr nc,ck_borderleft
	cp 10 \ jr nc,ck_borderright
	jr ck_ycheck
ck_borderleft:
	xor a
	jr ck_ycheck
ck_borderright:
	ld a,10
ck_ycheck:
	ld (viewX),a
	ld a,(zeldaY)
	sub 3
	cp 200	\ jr nc,ck_borderup
	cp 8	\ jr nc,ck_borderdown
	jr ck_endcheck
ck_borderup:
	xor a
	jr ck_endcheck
ck_borderdown:
	ld a,8
ck_endcheck:
	ld (viewY),a


;==========================================================
; charDraw
;==========================================================
charDraw:
	ld a,(zeldaDirection)
	add a,a
	add a,a
	ld h,0 \ ld l,a
	ld de,charGraphicCombinations
	add hl,de
	ex de,hl
	ld a,(charCycle)
	add a,a
	add a,a
	add a,a
	add a,a
	ld h,0 \ ld l,a
	add hl,de
	push hl
	pop ix

	ld a,(zeldaY)
	ld l,a
	ld a,(zeldaX)
	ld h,a

	ld de,char
	call drawThing
	ret

;==========================================================
; drawThing
;==========================================================
; this draws something if its in the window
; input: h=xpos l=ypos de=sprites pointer ix=table pointer
drawThing:
	ld a,(ix)	
	call drawThing8x8
	inc ix
	ld a,(ix)
	inc h
	call drawThing8x8
	dec h
	inc l
	inc ix
	ld a,(ix)
	call drawThing8x8
	inc ix
	ld a,(ix)
	inc h
	call drawThing8x8
	ret

drawThing8x8:
	;input: h=x l=y de=spritelist_begin a=sprite_nr
	push ix
	push af
	push hl
	push af
	ld a,(viewX)
	sub h
	neg
	cp 10 \ jr nc,drawThing8x8_quit
	ld h,a
	ld a,(viewY)
	sub l
	neg
	cp 8 \ jr nc,drawThing8x8_quit
	add a,a
	add a,a
	add a,a
	ld l,a
	pop af
	push de
	call gsAlignedMaskedSprite
	pop de
	push af
drawThing8x8_quit:
	pop af
	pop hl
	pop af
	pop ix
	ret

;==========================================================
; Code includes
;==========================================================
	#include map.inc
	#include math.inc

;==========================================================
; grayscale include file
;==========================================================
; comment these defines in or out to activate/deactivate them

;#DEFINE NODOUBLEBUFFER	;when on,routines write directly to screen (faster and smaller)
			;doesnt seem to work yet (i'll try to fix it)
;#DEFINE 3LEVELGRAY	;makes it 3-level grayscale (a bit faster)

#DEFINE GETK		;includes gsGetk
#DEFINE XORSPRITE	;includes gsPutSprite
#DEFINE LARGESPRITE	;includes gsLargeSprite
#DEFINE ALIGNEDSPRITE	;includes gsAlignedsprite
#DEFINE ALIGNEDMASKEDSPRITE

#include graylib.inc

charGraphicCombinations:
	.db 0,1,2,3		;up
	.db 4,5,6,7		;right
	.db 8,9,10,11		;down
	.db 5+128,4+128,7+128,12 ;left

	.db 13,14,15,16		;up2
	.db 17,18,19,20		;right2
	.db 21,22,23,24	;down2
	.db 18+128,17+128,20+128,25 ;left2

;==========================================================
; sprite includes
;==========================================================
tiles1:
#INCLUDE	tiles1.asm
tiles2:
;#INCLUDE	tiles2.asm
char:
#INCLUDE	char.asm

;==========================================================
; other data includes
;==========================================================
convert:
#INCLUDE	convert.asm
map0:
#INCLUDE	map0.asm
#INCLUDE	tempdat.asm

.end
END
