Sequential Search - brute force
    all possible candidates
    return index found or -1 if not found
    2,3,5,8,1,9,4
    7 elements
    search for key=2, return 0
    search for key=5, return 2
    search for key=7, return -1

    A[n] <- k search for k
    i = 0
    while (A[i] != k do
        i = i + 1
    if i < n return i
    return -1


Bubble Sort -> sink down
    for i <- 0 to a-2 do
        for j <- 0 to n-2-i do
            if A[j+1] < A[j] swap(A[j], A[j-1])


String Match


Selection Sort
    for i <- 0 to n-2 do
        min <- i
        for j <- i+1 to n-1 do
            if A[j] < A[min] min <- j
        swap(A[i]. A[min])


Merge Sort, divide & conquer
    3 steps:
    1. divide
    2. conquer
    3. combine
    recursivre w/termination @empty or single array
    Input: unsorted list, divide by 2 recursively
           merge smaller lists into larger list

            8 | 3 | 2 | 9 | 7 | 1 | 5 | 4

        8 | 3 | 2 | 9             7 | 1 | 5 | 4

    8 | 3           2 | 9       7 | 1       5 | 4
    8 > 3           2 < 9       7 > 1       5 > 4
    3 | 8           2 | 9       1 | 7       4 | 5

        2 | 3 | 8 | 9             1 | 4 | 5 | 7

            1 | 2 | 3 | 4 | 5 | 7 | 8 | 9

    Algorithm: MergeSort(A[0..n-1])
        Input: A[0..n-1]
        Output: Sorted A[0..n-1]
    1. i n > 1
    2.     copy A[0..n/2-1] to B[0..n/2-1] # split to 2 arrays
    3.     copy A[n/2..n-1] to C[0..n/2-1]
    4.     mergesort(B[0..n/2-1])
    5.     mergesort(C[0..n/2-1])
    6.     merge(B, C, A) # called w/only single or sorted lists

    Algorithm: Merge(B[0..p-1], C[0..q-1], A[0..p+q-1])
        Input: Sorted arrays B[0..p-1], C[0..q-1]
        Output: Sorted array A[0..p+q-1] 
          B       C       A
    1. i <- 0; j <- 0; k <- 0
    2. while i < p and j < q do // while elements in B & C
    3.     if B[i] <= C[j]
    4.          A[k] = B[i]; i <- i + 1
    5.     else A[k] = C[j]; j <- j + 1
    6.     k <- k + 1
    7. if i = p // array B is exhausted so copy C to A
    8.      copy C[j..q-1] to A[k..p+q-1]
    9. else copy B[i..p-1] to A[k..p+q-1] 


QuickSort
Hoare Partition


Binary Search


Insertion Sort


DFS


BFS


Transform and Conquer


Heaps and Heapsort


Floyd


Prim


Kruskal


RSA


