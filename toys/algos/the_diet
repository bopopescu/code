2/8/2017 8:47:32 AM     C:\code\toys\algos\the_diet


Very top level:
==============
[ ] discrete math - proofs "How to prove it" Velleman
[ ] algos/ds - CLRS
[ ] net - sockets
[ ] security - aes 
[ ] crypto - ??? sedgwick


Review:
======
[ ] Brute force:
    [x] udemy> selection sort
    [x] udemy> bubble sort
    [x] udemy> sequential search
    [x] udemy> string match
[ ] Divide and Conquer: 
    [x] udemy> merge sort
    [x] udemy> quicksort
[ ] Decrease and Conquer
    [x] udemy> binary search
    [x] udemy> insertion sort


C# (Oop.cs)
===
[x] Creating Classes
[ ] Creating Class Hierarchies
[ ] Implementing Object Collaboration
[ ] Working with Collections
    [ ] Array   
    [ ] String  
    [ ] List    
    [ ] Hash    
[ ] Linq
[ ] Threads, Delegates, Lambdas

Design Patterns (C# as model):
=============================


Notebook:
========
Data structures:
    [x] List
        * iterate, insert, delete
        * reverse, merge, zip
        * cycle detect
        * single, double linked
        * links and arrays
        * stacks and queues
    [x] Hash
        * fast insert, delete, lookup
        * bad order
        * array & collision chains
        * hash functions: integers, strings, objects
    [x] Tree
        * hierarchical data
        * depth, height, search path, find min/max
        * traversals, successor/predecessor, resource mgmt/locking
        * balance operations
    [x] Graph
    [x] Heap
        * fast lookup, insertion, delete max/min
        * node and array variants
        * merge sort
    [ ] String
        * compare, copy, match, join, split
    [ ] Primitives
        * bitwise ops

Algorithm Analysis Patterns:
===========================
    [ ] Concrete examples (greatest amount of change): 
        * manual solve instances, then build general solution
        * small inputs, arrays, small tree
        * specialized inputs to illustrate instance
    [ ] Case analysis (largest 3 of 25): 
        * split, solve chunks in isolation, cover all possiblities
    [ ] Iterative refinement (): 
        * start with brute force, then refine it
    [ ] Reduction (): 
        * use solution to other well known problem as a subroutine
    [ ] Graph modeling (): 
        * describe problem using graph, use graph algorithm

    Summing formulas:
        Sum of n consecutive positives = (n+1)n/2
        sum of n positive evens = n(n+1)
        sum of n odds = n^2
        sum of consecutive powers of 2 = 2^(n+1) - 1
        chess board rice doubling: 2^64 - 1
    Iterative:
        square build up rate: 2n^2 - 2n + 1
        #52 triangle build up
    Recursive:
        [ ] hanoi.c

Algorithm Design Patterns:
=========================
    [ ] Brute force:
        Exhaustive Search & Sort (Brute force)
        puzzles> Magic Squares
        puzzles> #29
        [x] udemy> selection sort: Sort.hpp
                set pos = 0, set min = a[pos], 
                scan entire list for smallest and swap with pos, inc pos
        [x] udemy> bubble sort (sink down): Sort.hpp
                iteratively descend, swap adjacent, sink maxes
        [x] udemy> sequential (linear) search: Search.hpp
        [x] udemy> string match: String.hpp

    [ ] Divide and Conquer: 
        * based on multi-branched recursion
        puzzles> Tromino puzzle
        puzzles> #37, 78
        [x] udemy> merge sort: Sort.hpp
        [x] udemy> quicksort

    [ ] Decrease and Conquer
        puzzles> Recursion
        puzzles> Celebrity problem
        puzzles> #4, 10, 3
        puzzles> 20 questions
        [x] udemy> binary search
        [x] udemy> insertion sort
        [ ] udemy> dfs
        [ ] udemy> bfs
        
    [ ] Sorting: 
        * uncover hidden structure

    [ ] Recursion: 
        * something defined in terms of itself
   
    [ ] Transform and Conquer
        puzzles> Tromino puzzle
        puzzles> #37, 78
        [ ] udemy> merge sort
        [ ] udemy> quicksort

    [ ] Dynamic Programming: 
        * break down problem into pre-stored chunks - cache
        puzzles> Shortest path counting
        puzzles> #13, 20, 62
        [ ] udemy> warshall
        [ ] udemy> floyd 

    [ ] Greedy: 
        * making locally optimal choices at each stage
        puzzles> non-attacking kings
        puzzles> bridge crossing at night
        puzzles> #7, 34
        [ ] udemy> prim - MST
        [ ] udemy> kruskal - MST

    [ ] Invariants: 
        * use to rule out potential solutions

    [ ] Backtracking: 
        * incrementally build candidate solutions, while abandoning others
        puzzles> n-Queens
        puzzles> State-space tree
        puzzles> #140
        
    [ ] Randomized: 
        * attempt to achieve average performance by deliberately 
        randomizing the input

    [ ] Branch and Bound: 
        * systematic enumeration of candidate solutions by means 
        of state space search

    [ ] Geometry:

    [ ] Pattern search:


Code Index:
==========
    Array (6):
        [x]     ring            :           :
        [ ]     dutch flag      : 6.1       :
    Concurrent (20):
        [x]     procon          : 20.7      : cool!!
    DP (17):
        [ ]     knapsack        : 17.6      :
    Graph (19):
        [x]     bfs             :           :
        [ ]     dfs             :           :
        [ ]     maze            : 19.1      :
    Greedy (18):
        [ ]     3-sum           : 18.4      :
    Hash (13):
        [x]     adt             :           : overload hash fun
        [ ]     palind-perms    : 13.1      : 
        [ ]     plagiarism      : 21.3      ; 
    Heap (11):
        [x]     max             :           : add(siftup, chk par), del(siftdown, chk lft & rt)
                                            : par = x/2, left=(2x)+1, right = 2x
        [ ]     merge/sort      : 11.1      : practical!!
    List (8,9):
        [x]     reverse         : 8.2       : p.next=r,q=p.next,r=p,p=q
        [x]     fifo            :           : diagram it
        [ ]     cycle           : 8.3       :
        [x]     merge           : 8.1       :
        [ ]     zip             :           :
        [x]     stack/max       : 9.1       : heap
        [ ]     stack/rpn       : 9.2       : 
    Network (24):
        [ ]     http            : mine
    Numbers (5):
        [ ]     parity          : 5.1
        [ ]     counting ones   :           :
        [ ]     rotate          :           : see numerics.c
    Patterns (23):
    Recursion (16):
        [ ]     hanoi           : 16.1      : see hanoi.c (work in progress)
    Search (12):
        [ ]     binsearch       : 12.1      :
    Sort (14):
        [ ]     intersect       : 14.1      :
    String (7):
        [x]     palindrome      : 7.5       : -> <- pointers len/2
        [x]     anagram         :           : use ascii table
        [ ]     regex/boyer     : 7.13      :
        [ ]     look & say      : 7.8       : 
    Tech (24):
        [ ]     xml
        [ ]     json
        [ ]     sqlite
        [ ]     sqlite
        [ ]     gtest
        [ ]     cmake
    Tree (10,15):
        [ ]     avl             :           :
        [ ]     intervals       : 25.5      : 
        [ ]     set             :           :
        [ ]     parse           :           :
        [x]     dfs             :           : stack
        [x]     bfs             :           : queue
        [ ]     node locking    : 10.17     : parent field

C++:
===
    [ ] Oop
        * copy & move constructor
    [ ] Facilities
        * tuples, bitsets, random nums, regex
        * I/O, exceptions
        * shared_ptr, unique_ptr
    [ ] Templates
    [ ] Functors
        * pointers to functors
    [ ] Literals
        * custom types
    [ ] Overloading
        * all operators
    [ ] STL
        * vector, map, list, string, tuple
    [ ] Algorithms
        * predicates, iterators
    [ ] Concurrency
        * threads, mutex, condition variables
        * producer/consumer, guards
    
Networking:
==========

